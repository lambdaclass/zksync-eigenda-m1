In the guest we first perform the call to `checkDACert` and check that it returned sucessfully:

```rust
 // Converts the input into a `EvmEnv` for execution.
let env = input.into_env(&ETH_HOLESKY_CHAIN_SPEC);

// Execute the view call; it returns the result in the type generated by the `sol!` macro.
let contract = Contract::new(cert_verifier_router_addr, &env);
let call = IVerifyBlob::checkDACertCall {
    eigendacert: eigenda_cert.to_abi_encoded().unwrap().into(),
};
let returns = contract.call_builder(&call).call();
// Here we assert that the result of the checkDACert call is succesfull
let status = CheckDACertStatus::try_from(returns).unwrap();

assert_eq!(
    status,
    CheckDACertStatus::Success,
    "CheckDACert call failed"
);
```

We then verify the `KZG Proof` for the Proof of Equivalence:

```rust
// Calculate the polynomial in evaluation form
let poly_coeff = blob.to_polynomial_coeff_form();
let poly_eval = poly_coeff.to_eval_form().unwrap();

// Get the commitment from eigenda cert
let cert_commitment = eigenda_cert
    .blob_inclusion_info
    .blob_certificate
    .blob_header
    .commitment
    .commitment;
// Compute evaluation challenge
let evaluation_challenge = compute_challenge(&blob, &cert_commitment).unwrap();

// Evaluate the polynomial at the evaluation challenge
let y = evaluate_polynomial_in_evaluation_form(&poly_eval, &evaluation_challenge).unwrap();

let evaled_y = eval(poly_coeff.coeffs(), evaluation_challenge);

// Assert that the evaluation of the polynomial at the evaluation challenge is equal to the y value
assert_eq!(y, evaled_y);

// Verification of the kzg proof for the given commitment, evaluation and evaluation challenge
let verified = verify_proof(cert_commitment, proof.g1, y, evaluation_challenge).unwrap();
assert!(verified);
```

We then calculate the hash of the blob:

```rust
// Here we calculate the keccak hash of the data, which we will use on zksync's EigenDAL1Validator to compare it to the hashes there
let hash = keccak256(&data);
```

At the end we return all the public outputs:

```rust
// Public outputs of the guest, eigenDAHash, commitment to the risc0 steel environment, blob info and proof, they are embedded on the risc0 proof
let output = Output {
    hash: hash.to_vec(),
    env_commitment: env.commitment().abi_encode(),
    inclusion_data: eigenda_cert.to_bytes().unwrap(),
    proof: proof_bytes,
};

env::commit(&output);
```
